require('../env');

const { Command } = require('commander');
const fs = require('fs');
const { Readable } = require('stream');

const { request, gql } = require('graphql-request');
const path = require('path');

const endpoint = process.env.PERSONAL_TOKEN
  ? `${process.env.API_URL}/graphql?personalToken=${process.env.PERSONAL_TOKEN}`
  : `${process.env.API_URL}/graphql/${process.env.API_KEY}`;

const expensesQuery = gql`
  query Account($slug: String, $types: [ExpenseType], $limit: Int) {
    expenses(account: { slug: $slug }, status: PAID, limit: $limit, types: $types) {
      totalCount
      nodes {
        id
        legacyId
        type
        items {
          id
          url
          file {
            name
          }
        }
        attachedFiles {
          id
          url
          name
        }
      }
    }
  }
`;

const getProgram = (argv) => {
  const program = new Command();
  program.exitOverride();
  program.showSuggestionAfterError();

  program.argument('<string>', 'The slug of the Account to export');
  program.argument('<string>', 'The export path');
  program.option('--types <string>', 'The types of expenses to export');
  program.option('--limit <number>', 'The number of expenses to export');
  program.option('--run', 'Trigger export.');
  program.parse(argv);

  return program;
};

const getPDFServiceHeaders = () => {
  return process.env.PERSONAL_TOKEN
    ? {
        'Personal-Token': process.env.PERSONAL_TOKEN,
      }
    : {
        'api-key': process.env.API_KEY,
      };
};

const downloadFile = async (url, filename, headers = {}) => {
  const response = await fetch(url, { headers });
  if (response.ok && response.body) {
    const writer = fs.createWriteStream(filename);
    Readable.fromWeb(response.body).pipe(writer);
  } else {
    throw new Error('Failed to download file:', url);
  }
};

async function main(argv = process.argv) {
  const program = getProgram(argv);
  const options = program.opts();
  const [slug, exportDir] = program.args;
  const limit = options.limit ? toInteger(options.limit) : 500;
  let types;

  if (!options.run) {
    console.log(`This is a dry run, run the script with --run to trigger it for real.`);
  }

  if (options.types) {
    types = options.types.split(',');
  }

  const result = await request(endpoint, expensesQuery, { slug, types, limit });
  console.log(`Total expenses: ${result.expenses.totalCount}`);
  console.log(`Exporting to: ${exportDir}`);

  // Create dest dir
  if (options.run && !fs.existsSync(exportDir)) {
    fs.mkdirSync(exportDir, { recursive: true });
  }

  for (const expense of result.expenses.nodes) {
    console.log(`Exporting expense ${expense.legacyId}`);
    const expenseDir = path.join(exportDir, `Expense-${expense.legacyId}`);
    const dirExists = fs.existsSync(expenseDir);
    if (options.run && dirExists) {
      console.log(`Directory already exists: ${expenseDir}, skipping expense ${expense.legacyId}...`);
      continue;
    } else {
      fs.mkdirSync(expenseDir, { recursive: true });
    }

    const attachedFiles = expense.attachedFiles || [];
    // Attached files
    for (const file of attachedFiles) {
      console.log(`Exporting file ${file.url}`);
      if (options.run) {
        const filename = file.name || `attached-file-${path.basename(decodeURIComponent(file.url))}`;
        await downloadFile(file.url, path.join(expenseDir, filename), headers);
      }
    }
    const items = expense.items?.filter((item) => item.url) || [];
    // Items
    for (const item of items) {
      console.log(`Exporting item ${item.url}`);
      if (options.run) {
        const filename = item.file?.name || `item-${path.basename(decodeURIComponent(item.url))}`;
        await downloadFile(item.url, path.join(expenseDir, filename), headers);
      }
    }

    // Autogenerated invoice
    if (expense.type === 'INVOICE') {
      console.log(`Exporting autogenerated invoice #${expense.id}`);
      if (options.run) {
        const invoiceUrl = `https://pdf.opencollective.com/expense/${expense.id}/invoice.pdf`;
        const headers = getPDFServiceHeaders();
        const filename = `OpenCollective-Invoice.pdf`;
        await downloadFile(invoiceUrl, path.join(expenseDir, filename), headers);
      }
    }
  }
}

if (!module.parent) {
  main()
    .then(() => process.exit())
    .catch((e) => {
      if (e.name !== 'CommanderError') {
        console.error(e);
      }

      process.exit(1);
    });
}
